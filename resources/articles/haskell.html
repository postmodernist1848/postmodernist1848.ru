<article>
    <h1>Look at this thing I've just learned about Haskell!</h1>
    <p>
        Я нашел такой удивительный пример кода на Хаскеле, что мне захотелось о нем написать здесь.
        Вот эти две-три строчки кода:
    </p>
    <img src="/assets/foldr.png" alt="foldr definition">
    <p>
        В Xаскеле есть то, что называется <code>typeclass</code>.
        По сути это интерфейс, который может реализовать ваш <code>datatype</code>, и это позволит
        использовать его в различных новых функциях.
        Пример <code>typeclass</code> - это <code>Eq</code>, для принадлежности к которому нужно определить функцию <code>(==)</code>.
        Другой - <code>Ord</code>, для которого нужно определить оператор сравнения.
        Это, например, требование для элементов списка-аргумента функции <code>sort</code>:
    </p>
    <img src="/assets/sort.png" alt="sort function from haskell standard library">
    <p>
        Итак, код выше - дефолтная реализация функции <code>foldr</code> для typeclass'а <code>Foldable</code> через функцию <code>foldMap</code>.
        Иными словами, чтобы принадлежать классу <code>Foldable</code>, можно просто реализовать <code>foldMap</code>. <code>Foldable</code> - класс
        типов, для которых определена свертка - просто применение бинарного оператора для получения одного результата.
        Пример левой свертки на Python:
    </p>
    <img src="/assets/python-reduce.png" alt="reduce python example">
    <p>
        Разумно полагать, что реализации <code>foldr</code> (правой свертки) хватает для принадлежности к классу <code>Foldable</code>.
        Однако как реализация странной функции <code>foldMap</code> позволяет реализовать <code>foldr</code>, а значит, принадлежать к этому классу?
        На самом деле, реализовать можно только одну из этих функций, а реализация по умолчанию второй позволит определить принадлежность к классу.
        Взглянем на сигнатуру функции <code>foldMap</code> (как я сказал, <code>foldMap</code> имеет дефолтную реализацию через <code>foldr</code>):
    </p>
    <img src="/assets/foldMapfoldr.png" alt="Foldable foldr and foldMap definition">
    <p>
        В <code>foldMap :: Monoid m => (a -> m) -> t a -> m</code> <code>Monoid m</code> означает что тип <code>m</code> принадлежит классу <code>Monoid</code>.
        Далее определяется функция с сигнатурой <code>(a -> m) -> t a -> m</code>, что означает, что функция <code>foldMap</code> принимает
        как аргумент функцию из типа <code>а</code> в тип <code>m</code>, т.е. <code>(a -> m)</code> и <code>Foldable</code>, содержащий тип <code>a</code>, а возвращает объект типа <code>m</code> класса <code>Monoid</code>.
        Иными словами, реализация этой функции должна,
        имея способ преобразовать элементы <code>Foldable</code> в моноид - некую функцию <code>f :: (a -> m)</code>, как-то свести весь <code>Foldable</code> к одному элементу.
        Для простоты можно думать о ,<code>Foldable</code> как о списке или коллекции объектов, так как список, очевидно, является <code>Foldable</code>,
        (хотя не все реализации <code>Foldable</code> содержат множество элементов, см. <code>Maybe</code>). Из курса общей алгебры мы знаем, что моноид - алгебраическая структура
        со следующими правилами: замкнутость, ассоциативность, наличие нейтрального элемента. Примерно так и определен класс <code>Monoid</code> в Xаскеле:
    </p>
        <img src="/assets/monoid.png">
    <p>
        <code>mempty</code> - нейтральный элемент, <code>mappend</code> - внутренний закон композиции моноида.
        Примеры моноидов в Xаскеле: <code>Sum a</code> - буквально числа со сложением, <code>[a]</code> (списки) - тоже моноид с оператором конкатенации <code>++</code>.
        Таким образом мы можем просто скомпозировать все элементы нашего <code>Foldable</code> под действием функции <code>(a -> m)</code>.
        <br>
        Возьмем двоичное дерево (каждая вершина либо пустая, либо имеет двух сыновей того же типа):
    </p>
        <img src="/assets/treedef.png">
    <p>
        Вот пример реализации <code>foldMap</code>:
    </p>
        <img src="/assets/treefoldmap.png">
    <p>
        Мы рекурсивно применяем <code>foldMap</code> к левому и правому поддереву и композируем моноиды (функция <code>f</code> принимает вершину и возвращает моноид)
        из левого поддерева, текущей вершины и правого поддерева. База рекурсии - пустая вершина, для которой возвращается нейтральный элемента моноида.
        Таким образом, все дерево было скомпозировано в один элемент моноида.
        <br>
        Теперь мы готовы к тому, чтобы разобрать то, что меня так поразило - реализацию функции <code>foldr</code>.
        Вот она еще раз:
    </p>
        <img src="/assets/foldr.png" alt="foldr definition">
    <p>
        Вся суть скрывается в функции <code>Endo</code>. <code>Endo</code> - тип класса <code>Monoid</code>.
        Название объясняется тем, что <code>Endo</code> - моноид эндоморфизмов
        (проще говоря, функций типа <code>(a -> a)</code>, собственно, так же,
        как и эндоморфизм является отображением из множества в (подмножество) себя).
        Довольно просто понять,
        что эндоморфизмы с оператором композиции функций является моноидом (замкнутость, ассоциативность тривиально доказываются, нейтральный - <code>id</code>, или f(x) = x).
        На самом деле, <code>Endo</code> такая же функция, как и любая другая, только она принимает на вход функцию и возвращает объекты типа эндоморфизм,
        который можно композировать с другими эндоморфизмами по закону этого моноида.
        Такие функции называются конструкторами типов. В данном случае конструктор типа единственный и называется так же, как и сам тип.
        Можно считать, что <code>Endo</code> - такая обертка вокруг функции <code>(a -> a)</code>, которая сопровождается операцией композиции <code>mappend</code> и прочими функциями моноида.
        На данном этапе нужно вспомнить одну из важнейших
        концепций Хаскеля - currying (названо в честь того самого Хаскелла Карри). На самом деле, все функции в Хаскеле принимают один аргумент.
        Функции типа <code>(a -> a -> a)</code> (как функция, которой мы делаем свертку, например)
        сначала принимают в себя единственный аргумент и возвращают функцию, которая принимает "следующий",
        отсюда такая, казалось бы, странная нотация.
        Поэтому мы можем делать такое:
    </p>
    <img src="/assets/currying.png" alt="currying example">
    <p>
        Здесь функция <code>+</code> (да, это функция) применяется к 3 и возвращает функцию <code>(a -> a)</code>,
        которая прибавляет 3 к своему (единственному) аргументу, а <code>map</code> применяет ее ко всем элементам списка.
        Итак, вернемся к реализации <code>foldr</code>. <code>Endo</code> можно скомпозировать (<code>.</code> - это композиция) c бинарной функцией,
        которой нам нужно сворачивать.
        В результате действительно получается функция <code>Endo</code>, примененная к результату <code>f</code> в <code>foldr</code>. Какой же результат <code>f</code>?
        Из-за currying <code>f</code> после применения к объекту типа <code>a</code> возвращает другую функцию <code>(a -> a)</code>, <b>из которой и конструируется наш эндоморфизм</b>.
        Таким образом, <code>foldMap</code> получает в себя <code>Endo . f</code> и из каждого элемента <code>Foldable</code> получает эндоморфизм.
        После этого <code>foldMap</code> композирует по закону моноида <code>Endo</code> все функции, то есть
        получает одну-единственную функцию - композицию всех - функцию типа <code>(a -> a)</code>.
    </p>
    <img src="/assets/foldr.png" alt="foldr definition">
    <p>
        <code>appEndo</code> просто "извлекает" функцию из конструктора типа <code>Endo</code>.
        Потом эта функция-композиция всех функций применяется к начальному элементу <code>z</code>,
        что на выходе дает элемент типа <code>a</code>.
        Почему это верная реализация правой свертки? Продемонстрируем на примере.
        Допустим, есть список <code>nums = [2, 4, 5]</code> и бинарная функция <code>(+)</code>. Мы делаем <code>foldr (+) 0 nums</code>.
        Предположим, что этот <code>foldr</code> использует реализацию по умолчанию, тогда <code>(+)</code> применяется к 2 и получается <code>(2+)</code>;
        <code>(2+)</code> композируется с <code>(4+)</code>, полученным таким же образом и скомпозированным с <code>(5+)</code>. Такая функция, которая сначала прибавляет 5, потом 4, потом 2,
        применяется к нулевому элементу и получается (2 + (4 + (5 + 0))), что явно выглядит как правая свертка.
    </p>
</article>
